/*
 * DFX API
 *
 * DFX API PRD (updated on 7/3/2025, 12:42:13 PM)
 *
 * The version of the OpenAPI document: v1
 * 
 * Generated by: https://openapi-generator.tech
 */

use crate::models;

#[derive(Clone, Default, Debug, PartialEq, Serialize, Deserialize)]
pub struct SwapPaymentInfoDto {
    /// Transaction order ID
    #[serde(rename = "id")]
    pub id: f64,
    /// UID of the transaction order
    #[serde(rename = "uid")]
    pub uid: String,
    /// Price timestamp
    #[serde(rename = "timestamp")]
    pub timestamp: String,
    #[serde(rename = "routeId")]
    pub route_id: f64,
    #[serde(rename = "depositAddress", skip_serializing_if = "Option::is_none")]
    pub deposit_address: Option<String>,
    #[serde(rename = "blockchain")]
    pub blockchain: String,
    #[serde(rename = "minDeposit")]
    pub min_deposit: Box<models::MinAmount>,
    /// Fee in percentage
    #[serde(rename = "fee")]
    pub fee: f64,
    /// Minimum fee in source asset
    #[serde(rename = "minFee")]
    pub min_fee: f64,
    /// Fee infos in source asset
    #[serde(rename = "fees")]
    pub fees: Box<models::FeeDto>,
    /// Minimum volume in source asset
    #[serde(rename = "minVolume")]
    pub min_volume: f64,
    /// Maximum volume in source asset
    #[serde(rename = "maxVolume")]
    pub max_volume: f64,
    /// Amount in source asset
    #[serde(rename = "amount")]
    pub amount: f64,
    /// Source asset
    #[serde(rename = "sourceAsset")]
    pub source_asset: Box<models::AssetDto>,
    /// Minimum fee in target asset
    #[serde(rename = "minFeeTarget")]
    pub min_fee_target: f64,
    /// Fee infos in target asset
    #[serde(rename = "feesTarget")]
    pub fees_target: Box<models::FeeDto>,
    /// Minimum volume in target asset
    #[serde(rename = "minVolumeTarget")]
    pub min_volume_target: f64,
    /// Maximum volume in target asset
    #[serde(rename = "maxVolumeTarget")]
    pub max_volume_target: f64,
    /// Exchange rate in source/target
    #[serde(rename = "exchangeRate")]
    pub exchange_rate: f64,
    /// Final rate (incl. fees) in source/target
    #[serde(rename = "rate")]
    pub rate: f64,
    /// Exact or approximate price
    #[serde(rename = "exactPrice")]
    pub exact_price: bool,
    #[serde(rename = "priceSteps")]
    pub price_steps: Vec<models::PriceStep>,
    /// Estimated amount in target asset
    #[serde(rename = "estimatedAmount")]
    pub estimated_amount: f64,
    /// Target asset
    #[serde(rename = "targetAsset")]
    pub target_asset: Box<models::AssetDto>,
    /// Payment request (e.g. Lightning invoice)
    #[serde(rename = "paymentRequest", skip_serializing_if = "Option::is_none")]
    pub payment_request: Option<String>,
    #[serde(rename = "isValid")]
    pub is_valid: bool,
    /// Error message in case isValid is false
    #[serde(rename = "error", skip_serializing_if = "Option::is_none")]
    pub error: Option<Error>,
}

impl SwapPaymentInfoDto {
    pub fn new(id: f64, uid: String, timestamp: String, route_id: f64, blockchain: String, min_deposit: models::MinAmount, fee: f64, min_fee: f64, fees: models::FeeDto, min_volume: f64, max_volume: f64, amount: f64, source_asset: models::AssetDto, min_fee_target: f64, fees_target: models::FeeDto, min_volume_target: f64, max_volume_target: f64, exchange_rate: f64, rate: f64, exact_price: bool, price_steps: Vec<models::PriceStep>, estimated_amount: f64, target_asset: models::AssetDto, is_valid: bool) -> SwapPaymentInfoDto {
        SwapPaymentInfoDto {
            id,
            uid,
            timestamp,
            route_id,
            deposit_address: None,
            blockchain,
            min_deposit: Box::new(min_deposit),
            fee,
            min_fee,
            fees: Box::new(fees),
            min_volume,
            max_volume,
            amount,
            source_asset: Box::new(source_asset),
            min_fee_target,
            fees_target: Box::new(fees_target),
            min_volume_target,
            max_volume_target,
            exchange_rate,
            rate,
            exact_price,
            price_steps,
            estimated_amount,
            target_asset: Box::new(target_asset),
            payment_request: None,
            is_valid,
            error: None,
        }
    }
}
/// Error message in case isValid is false
#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, Hash, Serialize, Deserialize)]
pub enum Error {
    #[serde(rename = "AmountTooLow")]
    AmountTooLow,
    #[serde(rename = "AmountTooHigh")]
    AmountTooHigh,
    #[serde(rename = "BankTransactionMissing")]
    BankTransactionMissing,
    #[serde(rename = "KycRequired")]
    KycRequired,
    #[serde(rename = "KycDataRequired")]
    KycDataRequired,
    #[serde(rename = "KycRequiredInstant")]
    KycRequiredInstant,
    #[serde(rename = "LimitExceeded")]
    LimitExceeded,
    #[serde(rename = "NationalityNotAllowed")]
    NationalityNotAllowed,
    #[serde(rename = "NameRequired")]
    NameRequired,
    #[serde(rename = "VideoIdentRequired")]
    VideoIdentRequired,
}

impl Default for Error {
    fn default() -> Error {
        Self::AmountTooLow
    }
}

